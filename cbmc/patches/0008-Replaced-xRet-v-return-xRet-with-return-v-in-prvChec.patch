From 7a1beb76f522c6f7984978f906bc2d9051b239bb Mon Sep 17 00:00:00 2001
From: "Mark R. Tuttle" <mrtuttle@amazon.com>
Date: Sun, 3 Mar 2019 06:58:25 -0500
Subject: [PATCH 8/8] Replaced 'xRet=v; return xRet;' with 'return v;' in
 prvCheckOptions'

---
 .../source/FreeRTOS_TCP_IP.c                  | 27 +++++++------------
 1 file changed, 9 insertions(+), 18 deletions(-)

diff --git a/lib/FreeRTOS-Plus-TCP/source/FreeRTOS_TCP_IP.c b/lib/FreeRTOS-Plus-TCP/source/FreeRTOS_TCP_IP.c
index c2819f9fc..23c34cc7b 100644
--- a/lib/FreeRTOS-Plus-TCP/source/FreeRTOS_TCP_IP.c
+++ b/lib/FreeRTOS-Plus-TCP/source/FreeRTOS_TCP_IP.c
@@ -1184,29 +1184,25 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 {
 	UBaseType_t uxNewMSS;
 	UBaseType_t xRemainingOptionsBytes = ( *ppucLast ) - ( *ppucPtr );
-	BaseType_t xRet = pdTRUE;
 	unsigned char ucLen;
 
 	if( ( *ppucPtr )[ 0 ] == TCP_OPT_END )
 	{
 		/* End of options. */
-		xRet = pdFALSE;
-		return xRet;
+		return pdFALSE;
 	}
 	if( ( *ppucPtr )[ 0 ] == TCP_OPT_NOOP)
 	{
 		/* NOP option, inserted to make the length a multiple of 4. */
 		( *ppucPtr )++;
-		xRet = pdTRUE;
-		return xRet;
+		return pdTRUE;
 	}
 
 	/* Any other well-formed option must be at least two bytes: the option
 	type byte followed by a length byte. */
 	if( xRemainingOptionsBytes < 2 )
 	{
-		xRet = pdFALSE;
-		return xRet;
+		return pdFALSE;
 	}
 #if( ipconfigUSE_TCP_WIN != 0 )
 	else if( ( *ppucPtr )[ 0 ] == TCP_OPT_WSOPT )
@@ -1214,8 +1210,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 		/* Confirm that the option fits in the remaining buffer space. */
 		if( ( xRemainingOptionsBytes < TCP_OPT_WSOPT_LEN ) || ( ( *ppucPtr )[ 1 ] != TCP_OPT_WSOPT_LEN ) )
 		{
-			xRet = pdFALSE;
-			return xRet;
+			return pdFALSE;
 		}
 
 		( *ppxSocket )->u.xTCP.ucPeerWinScaleFactor = ( *ppucPtr )[ 2 ];
@@ -1228,8 +1223,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 		/* Confirm that the option fits in the remaining buffer space. */
 		if( ( xRemainingOptionsBytes < TCP_OPT_MSS_LEN )|| ( ( *ppucPtr )[ 1 ] != TCP_OPT_MSS_LEN ) )
 		{
-			xRet = pdFALSE;
-			return xRet;
+			return pdFALSE;
 		}
 
 		/* An MSS option with the correct option length.  FreeRTOS_htons()
@@ -1242,8 +1236,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 			/* Perform a basic check on the the new MSS. */
 			if( uxNewMSS == 0 )
 			{
-				xRet = pdFALSE;
-				return xRet;
+				return pdFALSE;
 			}
 
 			FreeRTOS_debug_printf( ( "MSS change %u -> %lu\n", ( *ppxSocket )->u.xTCP.usInitMSS, uxNewMSS ) );
@@ -1269,8 +1262,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 
 		#if( ipconfigUSE_TCP_WIN != 1 )
 			/* Without scaled windows, MSS is the only interesting option. */
-			xRet = pdFALSE;
-			return xRet;
+			return pdFALSE;
 		#else
 			/* Or else we continue to check another option: selective ACK. */
 			( *ppucPtr ) += TCP_OPT_MSS_LEN;
@@ -1286,8 +1278,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 			/* If the length field is too small or too big, the options are
 			 * malformed, don't process them further.
 			 */
-			xRet = pdFALSE;
-			return xRet;
+			return pdFALSE;
 		}
 
 		#if( ipconfigUSE_TCP_WIN == 1 )
@@ -1312,7 +1303,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 
 		( *ppucPtr ) += ucLen;
 	}
-	return xRet;
+	return pdTRUE;
 }
 
 /*-----------------------------------------------------------*/
-- 
2.21.0

