From 85c60dba6d90adf3e9c8be01e8dfa9b155583eae Mon Sep 17 00:00:00 2001
From: "Mark R. Tuttle" <mrtuttle@amazon.com>
Date: Tue, 26 Feb 2019 17:24:25 -0500
Subject: [PATCH 7/8] In prvCheckOptions refactoring, added "return xRet" after
 every "xRet="

In the original refactoring, we did return VAL to simulate a break or
continue where VAL indicated continue or not continue the outer loop.
The current refactoring sets xRet and returns only from the bottom of the
loop, but now the code falls through and executes code at the bottom of
the loop before returning xRet.  Fixed that.
---
 lib/FreeRTOS-Plus-TCP/source/FreeRTOS_TCP_IP.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/lib/FreeRTOS-Plus-TCP/source/FreeRTOS_TCP_IP.c b/lib/FreeRTOS-Plus-TCP/source/FreeRTOS_TCP_IP.c
index 06bc6a2d6..c2819f9fc 100644
--- a/lib/FreeRTOS-Plus-TCP/source/FreeRTOS_TCP_IP.c
+++ b/lib/FreeRTOS-Plus-TCP/source/FreeRTOS_TCP_IP.c
@@ -1191,12 +1191,14 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 	{
 		/* End of options. */
 		xRet = pdFALSE;
+		return xRet;
 	}
 	if( ( *ppucPtr )[ 0 ] == TCP_OPT_NOOP)
 	{
 		/* NOP option, inserted to make the length a multiple of 4. */
 		( *ppucPtr )++;
 		xRet = pdTRUE;
+		return xRet;
 	}
 
 	/* Any other well-formed option must be at least two bytes: the option
@@ -1204,6 +1206,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 	if( xRemainingOptionsBytes < 2 )
 	{
 		xRet = pdFALSE;
+		return xRet;
 	}
 #if( ipconfigUSE_TCP_WIN != 0 )
 	else if( ( *ppucPtr )[ 0 ] == TCP_OPT_WSOPT )
@@ -1212,6 +1215,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 		if( ( xRemainingOptionsBytes < TCP_OPT_WSOPT_LEN ) || ( ( *ppucPtr )[ 1 ] != TCP_OPT_WSOPT_LEN ) )
 		{
 			xRet = pdFALSE;
+			return xRet;
 		}
 
 		( *ppxSocket )->u.xTCP.ucPeerWinScaleFactor = ( *ppucPtr )[ 2 ];
@@ -1225,6 +1229,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 		if( ( xRemainingOptionsBytes < TCP_OPT_MSS_LEN )|| ( ( *ppucPtr )[ 1 ] != TCP_OPT_MSS_LEN ) )
 		{
 			xRet = pdFALSE;
+			return xRet;
 		}
 
 		/* An MSS option with the correct option length.  FreeRTOS_htons()
@@ -1238,6 +1243,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 			if( uxNewMSS == 0 )
 			{
 				xRet = pdFALSE;
+				return xRet;
 			}
 
 			FreeRTOS_debug_printf( ( "MSS change %u -> %lu\n", ( *ppxSocket )->u.xTCP.usInitMSS, uxNewMSS ) );
@@ -1264,6 +1270,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 		#if( ipconfigUSE_TCP_WIN != 1 )
 			/* Without scaled windows, MSS is the only interesting option. */
 			xRet = pdFALSE;
+			return xRet;
 		#else
 			/* Or else we continue to check another option: selective ACK. */
 			( *ppucPtr ) += TCP_OPT_MSS_LEN;
@@ -1280,6 +1287,7 @@ BaseType_t prvSingleStepTCPHeaderOptions( const unsigned char ** const ppucPtr,
 			 * malformed, don't process them further.
 			 */
 			xRet = pdFALSE;
+			return xRet;
 		}
 
 		#if( ipconfigUSE_TCP_WIN == 1 )
-- 
2.21.0

