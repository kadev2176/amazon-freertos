/* Standard includes. */
#include <string.h>
#include <stdio.h>

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "FreeRTOS_CLI_Console.h"


#define cmdMAX_INPUT_BUFFER_SIZE    50

#define cmdMAX_COMMAND_SIZE         50

#define cmdMAX_OUTPUT_SIZE          80

#define cmdMAX_ERROR_SIZE           50

/* DEL acts as a backspace. */
#define cmdASCII_DEL                ( 0x7F )

#define cmdERROR_DELAY              ( 1000 )

/* Const messages output by the command console. */
static const char * const pcEndOfOutputMessage = "\r\n[Press ENTER to execute the previous command again]\r\n>";
static const char * const pcNewLine = "\r\n";

static char cInputBuffer[ cmdMAX_INPUT_BUFFER_SIZE ] = "";
static char cCommandString[ cmdMAX_COMMAND_SIZE ] = "";
static char cOutputString[ cmdMAX_OUTPUT_SIZE ] = "";
static char cErrorString[ cmdMAX_ERROR_SIZE ] = "";

static uint8_t ucCommandIndex = 0;

static void processInputBuffer( xConsoleIO_t consoleIO,
                                int32_t inputSize );

void FreeRTOS_CLIEnterConsoleLoop( xConsoleIO_t consoleIO )
{
    if( ( consoleIO.read == NULL ) || ( consoleIO.write == NULL ) )
    {
        return;
    }

    int32_t status;

    for( ; ; )
    {
        /* Read characters to input buffer. */
        status = consoleIO.read( cInputBuffer, cmdMAX_INPUT_BUFFER_SIZE - 1 );

        if( status >= 0 )
        {
            /* Echo back. */
            consoleIO.write( cInputBuffer, status );

            processInputBuffer( consoleIO, status );
        }
        else
        {
            snprintf( cErrorString, cmdMAX_ERROR_SIZE, "Read failed with error %d\n", ( int ) status );
            consoleIO.write( cErrorString, sizeof( cErrorString ) );
            memset( cErrorString, 0x00, cmdMAX_ERROR_SIZE );

            vTaskDelay( pdMS_TO_TICKS( cmdERROR_DELAY ) );
        }

        /* Reset input buffer for next iteration. */
        memset( cInputBuffer, 0x00, cmdMAX_INPUT_BUFFER_SIZE );
    }
}

static void processInputBuffer( xConsoleIO_t consoleIO,
                                int32_t inputSize )
{
    BaseType_t xReturned;
    uint8_t i = 0;

    for( ; i < inputSize; i++ )
    {
        char cRxedChar = cInputBuffer[ i ];

        /* A character was entered.  Add it to the string entered so
         * far.  When a \n is entered the complete	string will be
         * passed to the command interpreter. */
        if( ( cRxedChar >= ' ' ) && ( cRxedChar <= '~' ) )
        {
            if( ucCommandIndex < cmdMAX_COMMAND_SIZE )
            {
                cCommandString[ ucCommandIndex ] = cRxedChar;
                ucCommandIndex++;
            }
        }
        else if( ( cRxedChar == '\b' ) || ( cRxedChar == cmdASCII_DEL ) )
        {
            /* Backspace was pressed.  Erase the last character in the string - if any. */
            if( ucCommandIndex > 0 )
            {
                ucCommandIndex--;
                cCommandString[ ucCommandIndex ] = '\0';
            }
        }
        /* Was it the end of the line? */
        else if( ( cRxedChar == '\n' ) || ( cRxedChar == '\r' ) )
        {
            /* Just to space the output from the input. */
            consoleIO.write( pcNewLine, sizeof( pcNewLine ) );

            /* No extra characters in command. */
            if( ucCommandIndex == 0 )
            {
                continue;
            }

            /* Pass the received command to the command interpreter.  The
             * command interpreter is called repeatedly until it returns
             * pdFALSE	(indicating there is no more output) as it might
             * generate more than one string. */
            do
            {
                /* Get the next output string from the command interpreter. */
                xReturned = FreeRTOS_CLIProcessCommand( cCommandString, cOutputString, cmdMAX_OUTPUT_SIZE - 1 );

                /* Write the generated string to the output. */
                consoleIO.write( cOutputString, cmdMAX_OUTPUT_SIZE - 1 );
            } while( xReturned != pdFALSE );

            /* All the strings generated by the input command have been
             * sent.  Clear the input string ready to receive the next command.
             * Remember the command that was just processed first in case it is
             * to be processed again. */
            ucCommandIndex = 0;
            memset( cCommandString, 0x00, cmdMAX_COMMAND_SIZE );

            consoleIO.write( pcEndOfOutputMessage, sizeof( pcEndOfOutputMessage ) );
        }
    }
}
